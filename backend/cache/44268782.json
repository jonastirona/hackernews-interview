{"hn_id": "44268782", "title": "OxCaml - a set of extensions to the OCaml programming language.", "url": "https://news.ycombinator.com/item?id=44268782", "article_url": "https://oxcaml.org/", "points": 213, "author": "lairv", "comments_count": 62, "time": 0, "full_article_html": "<main class=\"grid-container\">\n<div class=\"hero\"></div>\n<div class=\"content-feature\">\n<div class=\"content-narrow\">\n<h1>OxCaml</h1>\n<h2>OxCaml is a fast-moving set of extensions to the OCaml programming language.</h2>\n<p>It is both Jane Street’s production compiler, as well as a laboratory for experiments focused towards making\n            OCaml better for performance-oriented programming. Our hope is that these extensions can over time be\n            contributed to upstream OCaml.</p>\n</div>\n</div>\n<div class=\"content-main\">\n<section class=\"content-narrow goals\">\n<h2>OxCaml’s primary design goals are:</h2>\n<ul>\n<li>to provide <span class=\"bold\">safe, convenient, predictable</span> control over performance-critical\n                aspects\n                of\n                program behavior </li>\n<li>but <span class=\"bold\">only where you need it,</span></li>\n<li>and…<span class=\"bold\">in OCaml!</span></li>\n</ul>\n</section>\n<section class=\"content-narrow\">\n<h2>Let’s talk about what this means!</h2>\n<p>OxCaml’s extensions are meant to make OCaml a great language for performance engineering. Performance\n            engineering\n            requires control, and we want that control to be:</p>\n<ul>\n<li>Safe. Safety is a critical feature for making programmers more productive, and for shipping correct\n                code.\n                Languages that are pervasively unsafe are too hard to use correctly.</li>\n<li>Convenient. We want to provide control without bewildering programmers, or drowning them in endless\n                annotations.\n                To achieve this, we aim to maintain OCaml’s excellent type-inference, even as we add considerable\n                expressiveness\n                to the type-system.</li>\n<li>Predictable. One of the great features of OCaml today is that it’s pretty easy to look at OCaml code and\n                understand how it’s going to perform. We want our extensions to maintain and improve on that property,\n                by\n                making\n                key performance details explicit at the type-level.</li>\n</ul>\n<p>By \"only where you need it\", we mean that OxCaml’s extensions should be pay-as-you-go. While OxCaml aims to\n            provide\n            more power to optimize, you shouldn’t need to swallow extra complexity when you’re not using that power.</p>\n<p>By \"in OCaml\", we mean that all valid OCaml programs are also valid OxCaml programs. But our more profound\n            goal\n            is\n            for OxCaml to feel like OCaml evolving into a better version of itself, rather than a new language. For\n            that,\n            OxCaml\n            needs to honor OCaml’s basic design sensibility, and to preserve the safety, ease, and productivity that are\n            hallmarks of the language.</p>\n</section>\n<section class=\"content-narrow\">\n<h2>OxCaml’s extensions </h2>\n<p>Our extensions can be roughly organized into a few areas:</p>\n<div class=\"cards-grid\">\n<div class=\"card\">\n<h2>Fearless concurrency</h2>\n<p>Writing correct concurrent programs is notoriously difficult. OxCaml includes additions to the\n                    type\n                    system to\n                    statically rule out data races.</p>\n</div>\n<div class=\"card\">\n<h2>Layouts</h2>\n<p>OxCaml lets programmers specify the way their data is laid out in memory. It also provides native\n                    access\n                    to\n                    SIMD processor extensions.</p>\n</div>\n<div class=\"card\">\n<h2>Control over allocation</h2>\n<p>OxCaml gives programmers tools to control allocations, reducing GC pressure and making programs\n                    more\n                    cache efficient and deterministic.</p>\n</div>\n<div class=\"card\">\n<h2>Quality of life </h2>\n<p>OxCaml also contains some extensions that aren’t specifically about systems programming, but\n                    which\n                    we’ve\n                    found helpful in our day-to-day work:</p>\n<ul>\n<li>Polymorphic parameters</li>\n<li>Include functor</li>\n<li>Labeled tuples</li>\n<li>Immutable arrays</li>\n</ul>\n</div>\n</div>\n</section>\n<section class=\"content-narrow\">\n<h2>Using OxCaml</h2>\n<p>OxCaml is open-source, and we’re excited to welcome experimental users, especially researchers and tinkerers\n            who\n            can\n            kick the tires and provide feedback on the system. We put the emphasis on experimental because OxCaml makes\n            no\n            promises of stability or backwards compatibility for its extensions (though it does remain backwards\n            compatible\n            with\n            OCaml).</p>\n<p>OxCaml is intended to be easy to use, and to that end comes with modified versions of the standard OCaml\n            tool-set,\n            including:</p>\n<ul>\n<li>Package management, compatible with dune and opam</li>\n<li>Editor integration via the LSP-server</li>\n<li>Source code formatting</li>\n<li>Documentation generation</li>\n</ul>\n<p>Jane Street has long open sourced a bunch of useful libraries and tools. These are now released in two forms:\n            one\n            for\n            upstream OCaml, in which our extensions have been stripped, and one for OxCaml, where the extensions are\n            fully\n            leveraged.</p>\n<p>Not all extensions are erasable, so some libraries will be available only for OxCaml. We’ll export\n            OCaml-compatible\n            versions of these libraries when the necessary extensions are integrated upstream.</p>\n</section>\n</div>\n</main>", "article_metadata": {"title": "OxCaml | About", "description": "", "og_image": ""}, "screenshot_path": "/static/screenshots/44268782.png", "screenshot_error": null, "hook": "Unlock unparalleled performance in OCaml without sacrificing safety or convenience—OxCaml, Jane Street's production compiler, offers powerful, predictable performance optimizations integrated seamlessly into the familiar OCaml ecosystem.  This innovative extension set provides granular control over performance-critical aspects, all while preserving OCaml's elegant type system and ease of use, paving the way for a more powerful and efficient future for the language.", "top_comments": [{"author": "rauljara", "text": "GC compactions were indeed a problem for a number of systems. The trading systems in general had a policy of not allocating after startup. JS has a library, called \"Zero\" that provides a host of non-allocating ways of doing things.", "depth": 0}, {"author": "jitl", "text": "Couldn’t find this after 6 seconds of googling, link?", "depth": 1}, {"author": "jallmann", "text": "The linked podcast episode mentions it.", "depth": 2}, {"author": "notnullorvoid", "text": "There's no mention of a library called zero, or even JavaScript.", "depth": 3}, {"author": "garbthetill", "text": "Im assuming the JS refers to Janes street", "depth": 4}, {"author": "jallmann", "text": "> This is what I like to call a dialect of OCaml. We speak in sometimes and sometimes we gently say it’s zero alloc OCaml. And the most notable thing about it, it tries to avoid touching the garbage collector ...", "depth": 5}, {"author": "great_wubwub", "text": "*Jane Street", "depth": 5}, {"author": "mardifoufs", "text": "You just let the garbage accumulate and collect it whenever markets are closed. In most cases, whenever you need ultra low latency in trading, you usually have very well defined time constraints (market open/close).\n\nMaybe it's different for markets that are always open (crypto?) but most HFT happens during regular market hours.", "depth": 1}, {"author": "dmkolobov", "text": "Is that really a viable solution for a timeframe of 6+ hours?", "depth": 1}, {"author": "jitl", "text": "Sure, if you know how much you allocate per minute (and don’t exceed your budget) you just buy enough RAM and it’s fine.", "depth": 2}], "analysis": {"analysis": "**1. Summary:**\n\nOxCaml is an open-source extension to the OCaml programming language developed by Jane Street, aiming to enhance performance for performance-critical applications while maintaining OCaml's safety and ease of use.  It achieves this through extensions focused on fearless concurrency, memory layout control, allocation management, and quality-of-life improvements.\n\n**2. Key Points:**\n\n* **Performance Focus:** OxCaml prioritizes providing safe and convenient control over performance-critical aspects of OCaml programs, particularly concerning concurrency, memory management, and allocation.\n* **Safety and Predictability:**  A core design goal is to maintain OCaml's safety and predictability, making performance optimizations explicit at the type level and avoiding pervasive unsafety.\n* **Extensibility and Compatibility:** OxCaml aims to be a seamless extension of OCaml, with all valid OCaml programs remaining valid in OxCaml.  The extensions are designed to be \"pay-as-you-go,\" adding complexity only when needed.\n* **Key Extension Areas:**  These include fearless concurrency (preventing data races), fine-grained control over memory layouts and SIMD instructions, allocation control to reduce GC pressure, and various quality-of-life improvements.\n* **Open-Source and Experimental:** OxCaml is open-source and welcomes experimental users to provide feedback.\n\n\n**3. Discussion Highlights:**\n\nThe comments highlight a significant discussion around memory management and garbage collection (GC) in high-performance applications, specifically within the context of financial trading systems.  The mention of Jane Street's \"Zero\" library (though its existence is debated in the comments) suggests a strategy of minimizing or eliminating allocations to avoid GC pauses.  However, the viability of this \"no allocation after startup\" approach for extended periods (e.g., 6+ hours) is questioned, with counterarguments suggesting sufficient RAM and careful allocation budgeting as alternatives.  The debate underscores the trade-offs between performance optimization techniques and their practical limitations in real-world applications.", "metadata": {"model": "gemini-1.5-flash", "content_length": 3825, "comments_analyzed": 10}}, "has_more": true}